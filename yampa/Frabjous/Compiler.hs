-- Compiler.hs
--
-- compiler for the Frabjous system
--
-- Oliver Schneider
-- University of Saskatchewan


module Frabjous.Compiler where

import Frabjous.Base
import Frabjous.Parser
import System.IO
import Data.Char (toLower)



---------------------------
-- Main Compiler Control --
---------------------------

-- used to test coherencyCheck and parser
test :: String -> IO ()
test filename = do 
	t <- parseFrabjousFile filename
	either print (putStrList . coherencyCheck) t


-- main compiler
compile :: String -> String -> IO ()
compile from to = do
			parseResult <- parseFrabjousFile from
			either print (handleParsed to) parseResult

-- takes a parsed model, checks for errors, and either outputs them or generates result file
handleParsed :: String -> TModel -> IO ()
handleParsed f t = if noErrors then genCode f t else putStrList errs
		where
			errs = coherencyCheck t
			noErrors = errs == []
			
			
-- putStrs a list of strings
putStrList :: [String] -> IO ()
putStrList [] = return ()
putStrList (x:xs) = putStrLn x >> putStrList xs



-------------------------------
-- code generation functions --
-------------------------------


-- main code generator
genCode :: String -> TModel -> IO ()
genCode filename m@(Model name env msgs nets diags confs agents) = do
					putStr $ "Compiling " ++ name ++ "..."
					handle <- openFile filename WriteMode
					let newLine = hPutStrLn handle ""
					
					genHeader handle name
					newLine
					genNetworks handle nets
					newLine
					genDiagrams_data handle diags
					newLine
					genDiagram_fns handle diags
					newLine
					
					hClose handle
					putStrLn "done."
					
					
					
					
					
genHeader handle modelname = do
				p $ "{-\n"
				p $ "Haskell/Yampa code for model " ++ modelname
				newLine
				p $ "Generated by Frabjous, developed at the University of Saskatchewan by"
				p $ "\tOliver Schneider,"
				p $ "\tChristopher Dutchyn,"
				p $ "\tNathaniel Osgood"
				p $ "\n-}"
				p $ "\n{-# LANGUAGE Arrows #-}\n"
				p $ "module Model_" ++ modelname ++ " where"
				newLine
				p $ "import Frabjous"
				p $ "import FRP.Yampa"
				newLine
			where
				p = hPutStrLn handle
				newLine = p ""
				
				
genNetworks handle nets = do
				hPutStrLn handle "-- network definitions\n"
				hPutStrLn handle $ formatted
				stdDeriv handle
				hPutStrLn handle ""
			where
				formatted = formatList "data Network =\t" "\n\t\t| " $ map netName $ map getName nets
				
				
genDiagrams_data handle diags = do
					hPutStrLn handle "-- data definition for diagrams\n"
					mapM (genDiagram_data handle) diags 
					hPutStrLn handle ""

genDiagram_data handle (Diagram name _ states) = do
							hPutStrLn handle $ formatted
							stdDeriv handle
							hPutStrLn handle ""
						where
							formatted = formatList init sep $ map (stateName name) $ map getName states
							init = "data Diagram_" ++ name ++ " =\t"
							sep = "\n\t\t\t| "



genDiagram_fns handle = mapM (genDiagram_fn handle)

genDiagram_fn handle (Diagram name start states) = do
							p header
							p dec
							p ""
							mapM (genState handle name) states
							p ""
				where
					header = "-- state definitions for diagram " ++ name
					dec = (diagName_sf name) ++ " = " ++ (stateName_sf name start)
					p = hPutStrLn handle

genState handle dn (State name msgs vars trans disp) = do
			p $ (stateName_sf dn name) ++ " = state output transitions"
			p $ "\twhere"
			p $ "\t\toutput = " ++ (stateName dn name)
			p $ decA
			mapM genTransition $ numberedTrans
			p ""
		where
			p = hPutStrLn handle
			decA = case trans of
					[] -> "\t\ttransitions = never -- no transitions from this state" 
					_  -> decA'
			decA' = formatList "\t\ttransitions = " " `lmerge` " $ map (\(_, n) -> "transition" ++ (show n)) $ numberedTrans
			genTransition ((Transition trig targ), n) = do
					--STUB!
					p $ "\t\ttransition" ++ (show n) ++ " = " ++ (map toLower (show trig)) ++ " " ++ (stateName_sf dn name)
			numberedTrans = trans `zip` [1..]
				
							
				
				
				
--------------------------
-- gen helper functions --
--------------------------

netName = (++) "Network_"

stateName d s = "State_" ++ d ++ "_" ++ s

stateName_sf d s = "state_" ++ d ++ "_" ++ s

diagName = (++) "Diagram_"

diagName_sf = (++) "diagram_"

stdDeriv handle = hPutStrLn handle $ "\tderiving(Show, Eq)"

formatList :: String -> String -> [String] -> String
formatList _ _ [] = ""
formatList init sep (x:xs) = init ++ x ++ (formatList' xs)
	where
		formatList' [] = ""
		formatList' (x:xs) = sep ++ x ++ (formatList' xs)
