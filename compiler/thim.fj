-- ---------------------------------
-- 1. Global Declarations
data State = S | I | R deriving (Eq, Show)

-- network people neighbours by (equivalenceClass state)

-- ---------------------------------
-- 2. Agent (Local) Declarations


agent Person { income:: Double, 
      	       state :: State
	     }

reactive state = statechart state transitions
  where infectionRatePerPerson = 0.4
        calcInfectionRate = proc input -> do
                                           nbs <- neighbors -< input 
                                           returnA -< infectionRatePerPerson * 
                                                       (fromIntegral (length (filter (==I) (map getState nbs))))
        transitions state = 
              case state of 
                     S -> pure I . rate . calcInfectionRate
                     I -> pure R . after 3
                     R -> pure S . after 3


--reactive income(t) = income(t) * 3

reactive income = income


agent Nbhd { avgIncome :: Double
           } 
{-
reactive avgIncome = arr (averageIncome) . residents
    where averageIncome people = (sum . map (getIncome) $ people) 
                                  / fromIntegral (length people)
-}

population people of Person
removal = arr (filter (\p -> getState p == R))


population nbhds of Nbhd



network nbhdNetwork between many neighbors in people = randomSymmetricNetwork 0.2 
